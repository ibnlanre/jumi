import { useEffect, useState } from "react";

function signal<T>(initialValue: T) {
  return new Signal(initialValue);
}

const number = signal(1);

export function Computed() {
  const computed = signal(number.current * 2);
  return (
    <div className='App'>{computed.value}</div>
  )
}

export function App(props) {
  return (
    <div className='App'>
      <h1>Hello React.</h1>
      <h2>Start editing to {number.current}</h2>

      <button onClick={() => {
        number.value++
      }}>Click me!</button>
    </div>
  );
}


const count = signal(0);
const peek = signal(count.value + 2);
const sideEffect = (value: number) => {
  console.log("count", value);
};

function Counter() {
  const double = signal(count.current * 3);
  const dispose = count.subscribe(sideEffect);

  return (
    <div className="text-white">
      <p>No Reactivity: value + 2 = {peek.value}</p>
      <button onClick={() => count.value++}>
        Value: {count.value}, value x 3 = {double.value}
      </button>
    </div>
  );
}

function Morphine(props: { count: number; onClick?: () => void }) {
  return (
    <button className="text-white" onClick={props.onClick}>
      {props.count}
    </button>
  );
}

<Counter />
<Morphine count={count.current} onClick={() => count.value++} />




------------------

import { signal } from "@ibnlanre/portal";

// this could equally be defined inside the component
const count = signal(0);
const sideEffect = (value) => {
  console.log("count", value);
};

// if defined within the Counter component
// peek.value would be updated when count changes
// because count.current causes a re-render
const peek = signal(count.value + 2);

function Counter() {
  // .current makes the value reactive, .value does not
  // but re-renders can make .value seem reactive
	const double = signal(count.current * 3);

  // subscriptions can happen within the component
  // because the callback is defined outside it
  const dispose = count.subscribe(sideEffect);

	return (
    <div>
      <p>No change: value + 2 = {peek.value}</p>
  		<button onClick={() => count.value++}>
			  Value: {count.value}, value x 3 = {double.value}
		  </button>
    </div>
	);
}


import { useEffect, useState } from "react";

function hash(...value: string[]) {
  let hash = 0;
  for (const char of value.join("")) {
    hash = (hash << 5) - hash + char.charCodeAt(0);
    hash |= 0;
  }
  return hash;
}

const signalEventKey = Symbol();
const signalEvent = new Event(signalEventKey.toString());

function isFunction<T>(value: T | (() => T)): value is () => T {
  return typeof value === "function";
}

class Signal<T> {
  private state: T = undefined as T;
  private subscribers: Set<(data: T) => void> = new Set();

  private use(initialValue: T = this.state) {
    const [value, setValue] = useState(initialValue);
    const identifier = hash(JSON.stringify(initialValue));

    useEffect(() => this.subscribe(setValue), []);
    useEffect(() => setValue(initialValue), [identifier]);

    return value;
  }

  constructor(initialValue: T = undefined as T) {
    this.state = initialValue;
    window.addEventListener(signalEventKey.toString(), () => {
      this.subscribers.forEach((fn) => fn(this.state));
    });
  }

  get value() {
    return this.state;
  }

  set value(newValue: T) {
    this.state = newValue;
    window.dispatchEvent(signalEvent);
  }

  get current() {
    return this.use();
  }

  subscribe = (callback: (value: T) => void, immediate = true) => {
    const unsubscribe = () => {
      this.subscribers.delete(callback);
    };

    if (this.subscribers.has(callback)) return unsubscribe;
    if (immediate) callback(this.state);

    this.subscribers.add(callback);
    return unsubscribe;
  };

  static identifier() {
    const error = new Error();
    const stack = error.stack?.split("\n").at(3) || "";
    const file = stack.replace(/[^a-zA-Z]/g, "");
    const path = stack.match(/:\d+:\d+/g)?.join("") || "";
    return hash(file, path);
  }
}

const store = new Map<number, Signal<any>>();

export function signal<T>(initialValue: T) {
  const uuid = Signal.identifier();

  if (store.has(uuid)) return store.get(uuid) as Signal<T>;
  store.set(uuid, new Signal<T>(initialValue));

  return store.get(uuid) as Signal<T>;

  // return new Signal<T>(initialValue);
}

export function useSignal<T>(signal: Signal<T>) {
  return signal.current;
}


////////////


import { Dispatch, SetStateAction, useEffect, useState } from "react";

const uuid = self.crypto.randomUUID();
const signalEvent = new Event(uuid);

function identifier() {
  const error = new Error();
  const stack = error.stack?.split("\n")?.slice(0, 4)?.filter(Boolean) || [];

  const key = stack.reduce((acc, curr) => {
    const file = curr.replace(/[^a-zA-Z]/g, "");
    const path = curr.match(/:\d+:\d+/g) || [];
    return acc + file + path.join("");
  }, "");

  return hash(key);
}

function hash(...value: string[]) {
  let hash = 0;

  for (const char of value.join("")) {
    hash = (hash << 2) - hash + char.charCodeAt(0);
    hash |= 0;
  }

  return hash.toString(16);
}


class Signal<T> {
  private state: T = undefined as T;
  private subscribers: Set<(data: T) => void> = new Set();

  use() {
    const [value, setValue] = useState(this.state);
    useEffect(() => this.subscribe(setValue), []);

    const setter: Dispatch<SetStateAction<T>> = (value) => {
      this.value =
        typeof value === "function"
          ? (value as (value: T) => T)(this.value)
          : (value as T);
    };

    return [value, setter] as [T, Dispatch<SetStateAction<T>>];
  }

  constructor(initialValue: T = undefined as T) {
    this.state = initialValue;
    window.addEventListener(uuid, () => {
      this.subscribers.forEach((fn) => fn(this.state));
    });
  }

  get value() {
    return this.state;
  }

  set value(newValue: T) {
    this.state = newValue;
    window.dispatchEvent(signalEvent);
  }

  subscribe = (callback: (value: T) => void, immediate = true) => {
    const unsubscribe = () => {
      this.subscribers.delete(callback);
    };

    if (this.subscribers.has(callback)) return unsubscribe;
    if (immediate) callback(this.state);

    this.subscribers.add(callback);
    return unsubscribe;
  };
}

class Computed<T> {
  private state: T;
  private subscribers: Set<(data: T) => void> = new Set();

  constructor(initialValue: () => T) {
    this.state = initialValue();

    window.addEventListener(uuid, () => {
      this.state = initialValue();

      this.subscribers.forEach((fn) => fn(this.state));
    });
  }

  get value() {
    return this.state;
  }

  subscribe = (callback: (value: T) => void, immediate = true) => {
    const unsubscribe = () => {
      this.subscribers.delete(callback);
    };

    if (this.subscribers.has(callback)) return unsubscribe;
    if (immediate) callback(this.state);

    this.subscribers.add(callback);
    return unsubscribe;
  };

  use() {
    const [value, setValue] = useState(this.state);
    useEffect(() => this.subscribe(setValue));
    return [value];
  }
}

const store = new Map<string, Signal<any> | Computed<any>>();

export function signal<T>(
  initialValue: T
): T extends () => infer U ? Computed<U> : Signal<T>;

export function signal<T>(initialValue: T | (() => T)) {
  // const uuid = identifier();

  // if (store.has(uuid)) {
  //   return store.get(uuid) as ReturnType<typeof signal>;
  // } else {
  //   const instance =
  //     typeof initialValue === "function"
  //       ? new Computed(initialValue as () => T)
  //       : new Signal(initialValue as T);

  //   store.set(uuid, instance);
  //   return instance;
  // }

  return typeof initialValue === "function"
    ? new Computed(initialValue as () => T)
    : new Signal(initialValue as T);
}
